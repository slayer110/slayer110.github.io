<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>reveal.js</title>

    <link rel="stylesheet" href="css/reset.css">
    <link rel="stylesheet" href="css/reveal.css">
    <link rel="stylesheet" href="css/theme/beige.css">

    <!-- Theme used for syntax highlighting of code -->
    <link rel="stylesheet" href="lib/css/monokai.css">

    <!-- Printing and PDF exports -->
    <script>
      var link = document.createElement('link');
      link.rel = 'stylesheet';
      link.type = 'text/css';
      link.href = window.location.search.match(/print-pdf/gi) ? 'css/print/pdf.css' : 'css/print/paper.css';
      document.getElementsByTagName('head')[0].appendChild(link);
    </script>
</head>
<body>
<div class="reveal">
    <div class="slides">
        <section><h1>Array.prototype</h1></section>
        <section data-background-size="500px" data-background-opacity="0.5">
            <h2>Some history</h2>
            <h3>ECMA standard 1st edition 1997 </h3>
            <ul>
                <li>Array.prototype.toString()</li>
                <li>Array.prototype.join()</li>
                <li>Array.prototype.reverse()</li>
                <li>Array.prototype.sort()</li>
            </ul>
        </section>
        <section><h2>ECMA standard 8st edition 2017</h2>
            <ul>
                <li class="fragment">Mutator methods</li>
                <li class="fragment">Accessor methods</li>
                <li class="fragment">Iteration methods</li>
                <li class="fragment">General methods</li>
            </ul>
        </section>
        <section><h2>Array.prototype.forEach() vs Array.prototype.map()</h2></section>
        <section><h2>Array.prototype.forEach()</h2>
            <h3>Syntax.</h3>
            <p><em>arr.forEach (function Callback (currentValue, Index, Array) {
                <span>//your iterator</span>});</em></p>
        </section>
        <section>
            <h3>Parameters.</h3>
            <p><em><b>Callback:</b></em>
                Function to execute on each element, taking three arguments:</p>
            <p style="font-size: 35px"><b><em>currentValue:</em></b>
                the current element being processed in the array.
            </p>
            <p style="font-size: 35px"><b><em>Index</em></b>(optional):
                the index of the current element being processed in the array.</p>
            <p style="font-size: 35px"><em><b>Array</b>(optinal)</em>:
                the array forEach() was called upon</p></section>
        <section>
            <h3>Example.</h3>
            <p>
                <em>let arr = [1, 2, 3, 4, 5];<br><br>
                    arr.forEach((num, index,array) => {<br>
                    array[index] = num * 2;
                    });
                </em>
            </p>
            <h3>Result:</h3>
            <p><em><span>//arr= [2, 4, 6, 8, 10]</span></em></p>

        </section>
        <section>

            <h2>Array.prototype.map()</h2>
            <h3>Example.</h3>
            <em><p>let doubled = arr.map(num => {<br>
                num * 2;
                });</em></p>

            <h3>Result:</h3>

            <p><em><span>// doubled = [2, 4, 6, 8, 10]</span></em></p>
        </section>
        <section>
            <h2>Speed comparison</h2>
            <img src="lib/images/speed.png">
            <p>As you can see, on my machine forEach() was more than 33% slower than map(). Your browser is probably
                different.</p>
        </section>
        <section>
            <h2>Key points</h2>
            <ul>
                <key-points>
                    <li>Just about anything you can do with forEach() you can do with <b>map()</b>, and vise versa.</li>
                </key-points>
                <key-points>
                    <li><b>map()</b> allocates memory and stores return values. <b>forEach()</b> throws away return
                        values and always
                        returns undefined.
                    </li>
                </key-points>
                <key-points>
                    <li><b>forEach()</b> will allow a callback function to mutate the current array. <b>map()</b> will
                        instead return a
                        new array.
                    </li>
                </key-points>
            </ul>
        </section>
        <section>
            <section><h2>Latest methods</h2>
                <ul>
                    <li>entries()&nbsp<span>(6th Edition, ECMA-262 2015);</span></li>
                    <br>
                    <li>copyWithin()&nbsp <span>(6th Edition, ECMA-262 2015);</span></li>
                    <br>
                    <li>includes() &nbsp<span>(7th Edition, ECMA-262 2016);</span></li>
                </ul>
            </section>
            <section>
                <h2>Array.prototype.entries()</h2>
                <p>
                    The entries () method returns a new Array Iterator array iterator object containing key / value
                    pairs for each index in the array.
                </p>
                <h3>Syntax</h3>
                <p><em>arr.entries().</em></p>
            </section>
            <section>
                <h3>Example.</h3>
                <em>
                    <p>let arr = ['a','b','c'];</p>
                    <p>let eArr=arr.entries();</p>
                    <p>console.log(eArr.next().value); <span> // [0, 'a']</span></p>
                    <p>console.log(eArr.next().value); <span> // [1, 'b']</span></p>
                    <p>console.log(eArr.next().value); <span> // [0, 'c']</span></p>
                </em>
            </section>
            <section>
                <h2>Array.prototype.copyWithin()</h2>
                <p>
                    The copyWithin () method copies a sequence of array elements inside it to a position starting at the
                    target index. A copy is taken of the indices given by the second and third arguments start and end.
                    The end argument is optional and defaults to the length of the array.
                </p>
            </section>
            <section>
                <h3>Syntax.</h3>
                <p><em>arr.copyWithin(target, start,end)</em></p>
            </section>
            <section>
                <h3>Parameters.</h3>
                <p><em><b>target:</b></em>
                    The initial index of the position of the target, where to copy the elements.</p>
                <p><b><em>start:</em></b>
                    The initial index of the position of the source from where to start copying items.
                </p>
                <p><b><em>end:</em></b>(optional):
                    The final index of the position of the source where to end copy elements.</p>
            </section>
            <section>
                <h3>Example.</h3>
                <em>
                    <p>[1,2,3,4,5].copyWithin(0,3); <span>//[4,5,3,4,5]</span></p>
                    <p>[1,2,3,4,5].copyWithin(0,3,4); <span>//[4,2,3,4,5]</span></p>
                    <p>[1,2,3,4,5].copyWithin(0,-2,-1); <span>//[4,2,3,4,5]</span></p>
                </em>
            </section>
            <section>
                <h2>Array.prototype.includes()</h2>
                <p>The includes() method determines whether an array includes a certain value among its entries,
                    returning true or false as appropriate.</p>
            </section>
            <section>
                <h3>Syntax.</h3>
                <p><em>arr.includes(valueToFind[, fromIndex])</em></p>
                <h3>Parameters</h3>
               <em><b>valueToFind:</b></em>
                    The value to search for.<br>
                <em><b style="font-size: 30px">fromIndex(optional):</b></em>
                    <span style="font-size: 30px;color:black"> The position in this array at which to begin searching for valueToFind; the first character to be
                    searched is found at fromIndex for positive values of fromIndex, or at array.length + fromIndex for
                    negative values of fromIndex (using the absolute value of fromIndex as the number of characters from
                       the end of the string at which to start the search). Defaults to 0.</span>
            </section>
            <section>
                <h3>Example.</h3>
                <em>
                    <p>[1, 2, 3].includes(2); <span>// true</span></p>
                    <p>[1, 2, 3].includes(4); <span>// false</span></p>
                    <p>[1, 2, 3].includes(3, 3); <span>// false</span></p>
                    <p>[1, 2, 3].includes(3, -1); <span>// true</span></p>
                    <p>[1, 2, NaN].includes(NaN); <span>// true</span></p>
                </em>
            </section>
            <section>
                <h1>Thanks for attention:)</h1>
            </section>
        </section>
    </div>
</div>

<script src="js/reveal.js"></script>
<script>
  // More info about config & dependencies:
  // - https://github.com/hakimel/reveal.js#configuration
  // - https://github.com/hakimel/reveal.js#dependencies
  Reveal.initialize({
    dependencies: [
      {src: 'plugin/markdown/marked.js'},
      {src: 'plugin/markdown/markdown.js'},
      {src: 'plugin/notes/notes.js', async: true},
      {src: 'plugin/highlight/highlight.js', async: true}
    ]
  });
</script>
</body>
</html>