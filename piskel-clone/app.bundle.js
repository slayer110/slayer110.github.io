!function(n){var e={};function t(r){if(e[r])return e[r].exports;var a=e[r]={i:r,l:!1,exports:{}};return n[r].call(a.exports,a,a.exports,t),a.l=!0,a.exports}t.m=n,t.c=e,t.d=function(n,e,r){t.o(n,e)||Object.defineProperty(n,e,{enumerable:!0,get:r})},t.r=function(n){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(n,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(n,"__esModule",{value:!0})},t.t=function(n,e){if(1&e&&(n=t(n)),8&e)return n;if(4&e&&"object"==typeof n&&n&&n.__esModule)return n;var r=Object.create(null);if(t.r(r),Object.defineProperty(r,"default",{enumerable:!0,value:n}),2&e&&"string"!=typeof n)for(var a in n)t.d(r,a,function(e){return n[e]}.bind(null,a));return r},t.n=function(n){var e=n&&n.__esModule?function(){return n.default}:function(){return n};return t.d(e,"a",e),e},t.o=function(n,e){return Object.prototype.hasOwnProperty.call(n,e)},t.p="",t(t.s=14)}([function(n,e){n.exports=function(n){function e(n){"undefined"!=typeof console&&(console.error||console.log)("[Script Loader]",n)}try{"undefined"!=typeof execScript&&"undefined"!=typeof attachEvent&&"undefined"==typeof addEventListener?execScript(n):"undefined"!=typeof eval?eval.call(null,n):e("EvalError: No eval function available")}catch(n){e(n)}}},function(n,e,t){var r=t(2);"string"==typeof r&&(r=[[n.i,r,""]]);var a={hmr:!0,transform:void 0,insertInto:void 0};t(4)(r,a);r.locals&&(n.exports=r.locals)},function(n,e,t){(n.exports=t(3)(!1)).push([n.i,"\r\n.header {\r\n  height: 28px;\r\n  box-shadow: 0 5px 5px -5px #333;\r\n  display: flex;\r\n  align-content: space-between;\r\n}\r\n\r\nbody {\r\n  overflow: hidden;\r\n}\r\n\r\n.tools {\r\n  position: relative;\r\n  z-index: -1;\r\n\r\n}\r\n\r\n#resize {\r\n  display: block;\r\n}\r\n\r\n.fa-bars {\r\n  float: left;\r\n  margin-left: 20px;\r\n}\r\n\r\n.header div:nth-child(2) {\r\n  width: 50%;\r\n  text-align: right;\r\n  margin-right: 20px;\r\n}\r\n\r\n.mainContent {\r\n  text-align: center;\r\n}\r\n\r\n.header div:nth-child(1) {\r\n  width: 50%;\r\n}\r\n.number{\r\n  position: relative;\r\n  z-index: 1;\r\n}\r\nspan {\r\n  margin-left: 10px;\r\n}\r\n\r\n.frames {\r\n  position: absolute;\r\n  left: 192px;\r\n  width: 195px;\r\n  height: 930px;\r\n  overflow: auto;\r\n}\r\n\r\n.frame {\r\n  position: relative;\r\n  width: 190px;\r\n  height: 190px;\r\n  background-color: #e3e3e3;\r\n  margin-top: 10px;\r\n}\r\n\r\n#addFrameButton {\r\n  margin-left: 40px;\r\n  margin-top: 5px;\r\n  width: 100px;\r\n  height: 30px;\r\n  cursor: pointer;\r\n  background-color: palevioletred;\r\n}\r\n\r\n.buttonDelete {\r\n  position: absolute;\r\n  width: 28px;\r\n  z-index: 0;\r\n  right: 11px;\r\n  top: 5px;\r\n  cursor: pointer;\r\n}\r\n\r\n.buttonCopy {\r\n  position: absolute;\r\n  width: 28px;\r\n  z-index: 6;\r\n  right: 11px;\r\n  bottom: 5px;\r\n  cursor: pointer;\r\n  background-color: #e3e3e3;\r\n}\r\n\r\n.icons {\r\n  width: 40px;\r\n  height: 40px;\r\n  background-color: black;\r\n}\r\n\r\n.settings {\r\n  position: absolute;\r\n  width: 250px;\r\n  height: 343px;\r\n  border: 1px solid #bcbcbc;\r\n  right: 0;\r\n  top: 41px;\r\n  box-shadow: 0 5px 5px -5px #333;\r\n  background-color: #bcbcbc;\r\n}\r\n\r\n.fa-ellipsis-v {\r\n  position: relative;\r\n  z-index: 3;\r\n  cursor: pointer;\r\n}\r\n\r\n.settings span {\r\n  font-size: 30px;\r\n  display: block;\r\n}\r\n\r\n#myCanvas {\r\n  position: relative;\r\n  margin-top: 455px;\r\n  image-rendering: pixelated;\r\n  background-color: #e3e3e3;\r\n}\r\n\r\n#auxiliaryCanvas {\r\n  position: absolute;\r\n  margin-top: 455px;\r\n  margin-left: -32px;\r\n  image-rendering: pixelated;\r\n  background-color:  black;\r\n  z-index: 5;\r\n}\r\n\r\n#preview {\r\n  margin-left: 20px;\r\n  margin-top: 68px;\r\n  border: 1px solid black;\r\n  background-color: #e3e3e3;\r\n  width:190px;\r\n  height:190px;\r\n}\r\n\r\n#grid {\r\n  background-color: orange;\r\n  position: absolute;\r\n  image-rendering: pixelated;\r\n  z-index: -1;\r\n}\r\n\r\n.menu {\r\n  left: 37px;\r\n  top: 113px;\r\n  position: absolute;\r\n  z-index: 5;\r\n  border: 1px solid #bcbcbc;\r\n  width: 109px;\r\n  height: 261px;\r\n  box-shadow: 0 5px 5px -5px #333;\r\n}\r\n\r\n.screen {\r\n  position: relative;\r\n  width: 932px;\r\n  height: 919px;\r\n  border: 1px solid black;\r\n  margin: 0 auto;\r\n  /*overflow: hidden;*/\r\n}\r\n\r\n.menu li {\r\n  height: 42px;\r\n  list-style-type: none;\r\n  border: 1px solid black;\r\n  margin-top: 4px;\r\n  color: #333;\r\n  box-sizing: border-box;\r\n}\r\n\r\n.tools {\r\n  padding-top: 3px;\r\n}\r\n\r\ni {\r\n  position: relative;\r\n  display: inline-block;\r\n  z-index: 1;\r\n  padding-top: 0;\r\n}\r\n\r\nli:hover {\r\n  cursor: pointer;\r\n}\r\n\r\n.menu a {\r\n  position: relative;\r\n  display: block;\r\n  border: 1px solid black;\r\n  width: 39px;\r\n  height: 19px;\r\n  text-decoration: none;\r\n  padding-top: 18px;\r\n}\r\n\r\n.colors {\r\n  position: relative;\r\n  top: -145px;\r\n  left: 56px;\r\n  width: 77%;\r\n  height: 30%;\r\n}\r\n\r\na:visited {\r\n  color: #7f7f7f;\r\n}\r\n\r\na:hover {\r\n  color: red;\r\n}\r\n\r\n#primaryColor {\r\n  display: block;\r\n  width: 36px;\r\n  height: 36px;\r\n  border: 1px solid black;\r\n}\r\n\r\n#secondaryColor {\r\n  display: block;\r\n  width: 36px;\r\n  height: 36px;\r\n  border: 1px solid black;\r\n  margin-left: 42px;\r\n}\r\n\r\n.color {\r\n  margin-right: 20px;\r\n  width: 20px;\r\n  height: 20px;\r\n  border-radius: 60px;\r\n  border: 2px solid black;\r\n  display: inline-block;\r\n}\r\n\r\n.colors li {\r\n  display: inline-block;\r\n  padding-right: 10px;\r\n}\r\n\r\n#currentColor {\r\n  background-color: grey;\r\n}\r\n\r\n#green {\r\n  background-color: green;\r\n}\r\n\r\n#red {\r\n  background-color: red;\r\n}\r\n\r\n#orange {\r\n  background-color: orange;\r\n}\r\n\r\n\r\n.fistColumn {\r\n  position: relative;\r\n  top: -10px;\r\n  height: 100%;\r\n  width: 43%;\r\n  padding-left: 4px;\r\n}\r\n#download{\r\n  position: absolute;\r\n  bottom:0;\r\n  left:20px;\r\n  cursor: pointer;\r\n  }\r\n.secondColumn {\r\n  float: right;\r\n  position: relative;\r\n  top: -307px;\r\n  height: 20px;\r\n  width: 47px;\r\n  margin-right: 4px;\r\n}\r\n::-webkit-scrollbar {\r\n  width: 4px;\r\n}\r\n\r\n::-webkit-scrollbar-track {\r\n  -webkit-box-shadow: inset 0 0 6px rgba(0,0,0,0.3);\r\n  border-radius: 10px;\r\n}\r\n\r\n::-webkit-scrollbar-thumb {\r\n  border-radius: 10px;\r\n  -webkit-box-shadow: inset 0 0 6px rgba(0,0,0,0.5);\r\n}\r\n.active{\r\n  border:2px solid red;\r\n}\r\nimg{\r\n  top:0;\r\n  left: 0;\r\n  position: absolute;\r\n  width: 190px;\r\n  height: 190px;\r\n  image-rendering: pixelated;\r\n}\r\n",""])},function(n,e,t){"use strict";n.exports=function(n){var e=[];return e.toString=function(){return this.map(function(e){var t=function(n,e){var t=n[1]||"",r=n[3];if(!r)return t;if(e&&"function"==typeof btoa){var a=(s=r,"/*# sourceMappingURL=data:application/json;charset=utf-8;base64,"+btoa(unescape(encodeURIComponent(JSON.stringify(s))))+" */"),i=r.sources.map(function(n){return"/*# sourceURL="+r.sourceRoot+n+" */"});return[t].concat(i).concat([a]).join("\n")}var s;return[t].join("\n")}(e,n);return e[2]?"@media "+e[2]+"{"+t+"}":t}).join("")},e.i=function(n,t){"string"==typeof n&&(n=[[null,n,""]]);for(var r={},a=0;a<this.length;a++){var i=this[a][0];null!=i&&(r[i]=!0)}for(a=0;a<n.length;a++){var s=n[a];null!=s[0]&&r[s[0]]||(t&&!s[2]?s[2]=t:t&&(s[2]="("+s[2]+") and ("+t+")"),e.push(s))}},e}},function(n,e,t){var r,a,i={},s=(r=function(){return window&&document&&document.all&&!window.atob},function(){return void 0===a&&(a=r.apply(this,arguments)),a}),o=function(n){var e={};return function(n,t){if("function"==typeof n)return n();if(void 0===e[n]){var r=function(n,e){return e?e.querySelector(n):document.querySelector(n)}.call(this,n,t);if(window.HTMLIFrameElement&&r instanceof window.HTMLIFrameElement)try{r=r.contentDocument.head}catch(n){r=null}e[n]=r}return e[n]}}(),l=null,c=0,d=[],u=t(5);function h(n,e){for(var t=0;t<n.length;t++){var r=n[t],a=i[r.id];if(a){a.refs++;for(var s=0;s<a.parts.length;s++)a.parts[s](r.parts[s]);for(;s<r.parts.length;s++)a.parts.push(b(r.parts[s],e))}else{var o=[];for(s=0;s<r.parts.length;s++)o.push(b(r.parts[s],e));i[r.id]={id:r.id,refs:1,parts:o}}}}function p(n,e){for(var t=[],r={},a=0;a<n.length;a++){var i=n[a],s=e.base?i[0]+e.base:i[0],o={css:i[1],media:i[2],sourceMap:i[3]};r[s]?r[s].parts.push(o):t.push(r[s]={id:s,parts:[o]})}return t}function f(n,e){var t=o(n.insertInto);if(!t)throw new Error("Couldn't find a style target. This probably means that the value for the 'insertInto' parameter is invalid.");var r=d[d.length-1];if("top"===n.insertAt)r?r.nextSibling?t.insertBefore(e,r.nextSibling):t.appendChild(e):t.insertBefore(e,t.firstChild),d.push(e);else if("bottom"===n.insertAt)t.appendChild(e);else{if("object"!=typeof n.insertAt||!n.insertAt.before)throw new Error("[Style Loader]\n\n Invalid value for parameter 'insertAt' ('options.insertAt') found.\n Must be 'top', 'bottom', or Object.\n (https://github.com/webpack-contrib/style-loader#insertat)\n");var a=o(n.insertAt.before,t);t.insertBefore(e,a)}}function m(n){if(null===n.parentNode)return!1;n.parentNode.removeChild(n);var e=d.indexOf(n);e>=0&&d.splice(e,1)}function g(n){var e=document.createElement("style");if(void 0===n.attrs.type&&(n.attrs.type="text/css"),void 0===n.attrs.nonce){var r=function(){0;return t.nc}();r&&(n.attrs.nonce=r)}return v(e,n.attrs),f(n,e),e}function v(n,e){Object.keys(e).forEach(function(t){n.setAttribute(t,e[t])})}function b(n,e){var t,r,a,i;if(e.transform&&n.css){if(!(i="function"==typeof e.transform?e.transform(n.css):e.transform.default(n.css)))return function(){};n.css=i}if(e.singleton){var s=c++;t=l||(l=g(e)),r=w.bind(null,t,s,!1),a=w.bind(null,t,s,!0)}else n.sourceMap&&"function"==typeof URL&&"function"==typeof URL.createObjectURL&&"function"==typeof URL.revokeObjectURL&&"function"==typeof Blob&&"function"==typeof btoa?(t=function(n){var e=document.createElement("link");return void 0===n.attrs.type&&(n.attrs.type="text/css"),n.attrs.rel="stylesheet",v(e,n.attrs),f(n,e),e}(e),r=function(n,e,t){var r=t.css,a=t.sourceMap,i=void 0===e.convertToAbsoluteUrls&&a;(e.convertToAbsoluteUrls||i)&&(r=u(r));a&&(r+="\n/*# sourceMappingURL=data:application/json;base64,"+btoa(unescape(encodeURIComponent(JSON.stringify(a))))+" */");var s=new Blob([r],{type:"text/css"}),o=n.href;n.href=URL.createObjectURL(s),o&&URL.revokeObjectURL(o)}.bind(null,t,e),a=function(){m(t),t.href&&URL.revokeObjectURL(t.href)}):(t=g(e),r=function(n,e){var t=e.css,r=e.media;r&&n.setAttribute("media",r);if(n.styleSheet)n.styleSheet.cssText=t;else{for(;n.firstChild;)n.removeChild(n.firstChild);n.appendChild(document.createTextNode(t))}}.bind(null,t),a=function(){m(t)});return r(n),function(e){if(e){if(e.css===n.css&&e.media===n.media&&e.sourceMap===n.sourceMap)return;r(n=e)}else a()}}n.exports=function(n,e){if("undefined"!=typeof DEBUG&&DEBUG&&"object"!=typeof document)throw new Error("The style-loader cannot be used in a non-browser environment");(e=e||{}).attrs="object"==typeof e.attrs?e.attrs:{},e.singleton||"boolean"==typeof e.singleton||(e.singleton=s()),e.insertInto||(e.insertInto="head"),e.insertAt||(e.insertAt="bottom");var t=p(n,e);return h(t,e),function(n){for(var r=[],a=0;a<t.length;a++){var s=t[a];(o=i[s.id]).refs--,r.push(o)}n&&h(p(n,e),e);for(a=0;a<r.length;a++){var o;if(0===(o=r[a]).refs){for(var l=0;l<o.parts.length;l++)o.parts[l]();delete i[o.id]}}}};var x,y=(x=[],function(n,e){return x[n]=e,x.filter(Boolean).join("\n")});function w(n,e,t,r){var a=t?"":r.css;if(n.styleSheet)n.styleSheet.cssText=y(e,a);else{var i=document.createTextNode(a),s=n.childNodes;s[e]&&n.removeChild(s[e]),s.length?n.insertBefore(i,s[e]):n.appendChild(i)}}},function(n,e){n.exports=function(n){var e="undefined"!=typeof window&&window.location;if(!e)throw new Error("fixUrls requires window.location");if(!n||"string"!=typeof n)return n;var t=e.protocol+"//"+e.host,r=t+e.pathname.replace(/\/[^\/]*$/,"/");return n.replace(/url\s*\(((?:[^)(]|\((?:[^)(]+|\([^)(]*\))*\))*)\)/gi,function(n,e){var a,i=e.trim().replace(/^"(.*)"$/,function(n,e){return e}).replace(/^'(.*)'$/,function(n,e){return e});return/^(#|data:|http:\/\/|https:\/\/|file:\/\/\/|\s*$)/i.test(i)?n:(a=0===i.indexOf("//")?i:0===i.indexOf("/")?t+i:r+i.replace(/^\.\//,""),"url("+JSON.stringify(a)+")")})}},function(n,e,t){t(0)(t(7))},function(n,e){n.exports="/**\r\n * This class lets you encode animated GIF files\r\n * Base class :  http://www.java2s.com/Code/Java/2D-Graphics-GUI/AnimatedGifEncoder.htm\r\n * @author Kevin Weiner (original Java version - kweiner@fmsware.com)\r\n * @author Thibault Imbert (AS3 version - bytearray.org)\r\n * @author Kevin Kwok (JavaScript version - https://github.com/antimatter15/jsgif)\r\n * @version 0.1 AS3 implementation\r\n */\nGIFEncoder = function () {\n  for (var i = 0, chr = {}; i < 256; i++) {\n    chr[i] = String.fromCharCode(i);\n  }\n\n  function ByteArray() {\n    this.bin = [];\n  }\n\n  ByteArray.prototype.getData = function () {\n    for (var v = '', l = this.bin.length, i = 0; i < l; i++) {\n      v += chr[this.bin[i]];\n    }\n\n    return v;\n  };\n\n  ByteArray.prototype.writeByte = function (val) {\n    this.bin.push(val);\n  };\n\n  ByteArray.prototype.writeUTFBytes = function (string) {\n    for (var l = string.length, i = 0; i < l; i++) {\n      this.writeByte(string.charCodeAt(i));\n    }\n  };\n\n  ByteArray.prototype.writeBytes = function (array, offset, length) {\n    for (var l = length || array.length, i = offset || 0; i < l; i++) {\n      this.writeByte(array[i]);\n    }\n  };\n\n  var exports = {};\n  var width; // image size\n\n  var height;\n  var transparent = null; // transparent color if given\n\n  var transIndex; // transparent index in color table\n\n  var repeat = -1; // no repeat\n\n  var delay = 0; // frame delay (hundredths)\n\n  var started = false; // ready to output frames\n\n  var out;\n  var image; // current frame\n\n  var pixels; // BGR byte array from frame\n\n  var indexedPixels; // converted frame indexed to palette\n\n  var colorDepth; // number of bit planes\n\n  var colorTab; // RGB palette\n\n  var usedEntry = []; // active palette entries\n\n  var palSize = 7; // color table size (bits-1)\n\n  var dispose = -1; // disposal code (-1 = use default)\n\n  var closeStream = false; // close stream when finished\n\n  var firstFrame = true;\n  var sizeSet = false; // if false, get size from first frame\n\n  var sample = 10; // default sample interval for quantizer\n\n  var comment = 'Generated by jsgif (https://github.com/antimatter15/jsgif/)'; // default comment for generated gif\n\n  /**\r\n   * Sets the delay time between each frame, or changes it for subsequent frames\r\n   * (applies to last frame added)\r\n   * int delay time in milliseconds\r\n   * @param ms\r\n   */\n\n  var setDelay = exports.setDelay = function setDelay(ms) {\n    delay = Math.round(ms / 10);\n  };\n  /**\r\n   * Sets the GIF frame disposal code for the last added frame and any\r\n   *\r\n   * subsequent frames. Default is 0 if no transparent color has been set,\r\n   * otherwise 2.\r\n   * @param code\r\n   * int disposal code.\r\n   */\n\n\n  var setDispose = exports.setDispose = function setDispose(code) {\n    if (code >= 0) dispose = code;\n  };\n  /**\r\n   * Sets the number of times the set of GIF frames should be played. Default is\r\n   * 1; 0 means play indefinitely. Must be invoked before the first image is\r\n   * added.\r\n   *\r\n   * @param iter\r\n   * int number of iterations.\r\n   * @return\r\n   */\n\n\n  var setRepeat = exports.setRepeat = function setRepeat(iter) {\n    if (iter >= 0) repeat = iter;\n  };\n  /**\r\n   * Sets the transparent color for the last added frame and any subsequent\r\n   * frames. Since all colors are subject to modification in the quantization\r\n   * process, the color in the final palette for each frame closest to the given\r\n   * color becomes the transparent color for that frame. May be set to null to\r\n   * indicate no transparent color.\r\n   * @param\r\n   * Color to be treated as transparent on display.\r\n   */\n\n\n  var setTransparent = exports.setTransparent = function setTransparent(c) {\n    transparent = c;\n  };\n  /**\r\n   * Sets the comment for the block comment\r\n   * @param\r\n   * string to be insterted as comment\r\n   */\n\n\n  var setComment = exports.setComment = function setComment(c) {\n    comment = c;\n  };\n  /**\r\n   * The addFrame method takes an incoming BitmapData object to create each frames\r\n   * @param\r\n   * BitmapData object to be treated as a GIF's frame\r\n   */\n\n\n  var addFrame = exports.addFrame = function addFrame(im, is_imageData) {\n    if (im === null || !started || out === null) {\n      throw new Error('Please call start method before calling addFrame');\n    }\n\n    var ok = true;\n\n    try {\n      if (!is_imageData) {\n        image = im.getImageData(0, 0, im.canvas.width, im.canvas.height).data;\n        if (!sizeSet) setSize(im.canvas.width, im.canvas.height);\n      } else {\n        if (im instanceof ImageData) {\n          image = im.data;\n\n          if (!sizeset || width != im.width || height != im.height) {\n            setSize(im.width, im.height);\n          } else {}\n        } else if (im instanceof Uint8ClampedArray) {\n          if (im.length == width * height * 4) {\n            image = im;\n          } else {\n            console.log('Please set the correct size: ImageData length mismatch');\n            ok = false;\n          }\n        } else {\n          console.log('Please provide correct input');\n          ok = false;\n        }\n      }\n\n      getImagePixels(); // convert to correct format if necessary\n\n      analyzePixels(); // build color table & map pixels\n\n      if (firstFrame) {\n        writeLSD(); // logical screen descriptior\n\n        writePalette(); // global color table\n\n        if (repeat >= 0) {\n          // use NS app extension to indicate reps\n          writeNetscapeExt();\n        }\n      }\n\n      writeGraphicCtrlExt(); // write graphic control extension\n\n      if (comment !== '') {\n        writeCommentExt(); // write comment extension\n      }\n\n      writeImageDesc(); // image descriptor\n\n      if (!firstFrame) writePalette(); // local color table\n\n      writePixels(); // encode and write pixel data\n\n      firstFrame = false;\n    } catch (e) {\n      ok = false;\n    }\n\n    return ok;\n  };\n  /**\r\n   * @description: Downloads the encoded gif with the given name\r\n   * No need of any conversion from the stream data (out) to base64\r\n   * Solves the issue of large file sizes when there are more frames\r\n   * and does not involve in creation of any temporary data in the process\r\n   * so no wastage of memory, and speeds up the process of downloading\r\n   * to just calling this function.\r\n   * @parameter {String} filename filename used for downloading the gif\r\n   */\n\n\n  var download = exports.download = function download(filename) {\n    if (out === null || closeStream == false) {\n      console.log('Please call start method and add frames and call finish method before calling download');\n    } else {\n      filename = filename !== undefined ? filename.endsWith('.gif') ? filename : filename + '.gif' : 'download.gif';\n      var templink = document.createElement('a');\n      templink.download = filename;\n      templink.href = URL.createObjectURL(new Blob([new Uint8Array(out.bin)], {\n        type: 'image/gif'\n      }));\n      templink.click();\n    }\n  };\n  /**\r\n   * Adds final trailer to the GIF stream, if you don't call the finish method\r\n   * the GIF stream will not be valid.\r\n   */\n\n\n  var finish = exports.finish = function finish() {\n    if (!started) return false;\n    var ok = true;\n    started = false;\n\n    try {\n      out.writeByte(0x3b); // gif trailer\n\n      closeStream = true;\n    } catch (e) {\n      ok = false;\n    }\n\n    return ok;\n  };\n  /**\r\n   * Resets some members so that a new stream can be started.\r\n   * This method is actually called by the start method\r\n   */\n\n\n  var reset = function reset() {\n    // reset for subsequent use\n    transIndex = 0;\n    image = null;\n    pixels = null;\n    indexedPixels = null;\n    colorTab = null;\n    closeStream = false;\n    firstFrame = true;\n  };\n  /**\r\n   * * Sets frame rate in frames per second. Equivalent to\r\n   * <code>setDelay(1000/fps)</code>.\r\n   * @param fps\r\n   * float frame rate (frames per second)\r\n   */\n\n\n  var setFrameRate = exports.setFrameRate = function setFrameRate(fps) {\n    if (fps != 0xf) delay = Math.round(100 / fps);\n  };\n  /**\r\n   * Sets quality of color quantization (conversion of images to the maximum 256\r\n   * colors allowed by the GIF specification). Lower values (minimum = 1)\r\n   * produce better colors, but slow processing significantly. 10 is the\r\n   * default, and produces good color mapping at reasonable speeds. Values\r\n   * greater than 20 do not yield significant improvements in speed.\r\n   * @param quality\r\n   * int greater than 0.\r\n   * @return\r\n   */\n\n\n  var setQuality = exports.setQuality = function setQuality(quality) {\n    if (quality < 1) quality = 1;\n    sample = quality;\n  };\n  /**\r\n   * Sets the GIF frame size. The default size is the size of the first frame\r\n   * added if this method is not invoked.\r\n   * @param w\r\n   * int frame width.\r\n   * @param h\r\n   * int frame width.\r\n   */\n\n\n  var setSize = exports.setSize = function setSize(w, h) {\n    if (started && !firstFrame) return;\n    width = w;\n    height = h;\n    if (width < 1) width = 320;\n    if (height < 1) height = 240;\n    sizeSet = true;\n  };\n  /**\r\n   * Initiates GIF file creation on the given stream.\r\n   * @param os\r\n   * OutputStream on which GIF images are written.\r\n   * @return false if initial write failed.\r\n   */\n\n\n  var start = exports.start = function start() {\n    reset();\n    var ok = true;\n    closeStream = false;\n    out = new ByteArray();\n\n    try {\n      out.writeUTFBytes('GIF89a'); // header\n    } catch (e) {\n      ok = false;\n    }\n\n    return started = ok;\n  };\n\n  var cont = exports.cont = function cont() {\n    reset();\n    var ok = true;\n    closeStream = false;\n    out = new ByteArray();\n    return started = ok;\n  };\n  /**\r\n   * Analyzes image colors and creates color map.\r\n   */\n\n\n  var analyzePixels = function analyzePixels() {\n    var len = pixels.length;\n    var nPix = len / 3;\n    indexedPixels = [];\n    var nq = new NeuQuant(pixels, len, sample); // initialize quantizer\n\n    colorTab = nq.process(); // create reduced palette\n    // map image pixels to new palette\n\n    var k = 0;\n\n    for (var j = 0; j < nPix; j++) {\n      var index = nq.map(pixels[k++] & 0xff, pixels[k++] & 0xff, pixels[k++] & 0xff);\n      usedEntry[index] = true;\n      indexedPixels[j] = index;\n    }\n\n    pixels = null;\n    colorDepth = 8;\n    palSize = 7; // get closest match to transparent color if specified\n\n    if (transparent !== null) {\n      transIndex = findClosest(transparent);\n    }\n  };\n  /**\r\n   * Returns index of palette color closest to c\r\n   */\n\n\n  var findClosest = function findClosest(c) {\n    if (colorTab === null) return -1;\n    var r = (c & 0xFF0000) >> 16;\n    var g = (c & 0x00FF00) >> 8;\n    var b = c & 0x0000FF;\n    var minpos = 0;\n    var dmin = 256 * 256 * 256;\n    var len = colorTab.length;\n\n    for (var i = 0; i < len;) {\n      var dr = r - (colorTab[i++] & 0xff);\n      var dg = g - (colorTab[i++] & 0xff);\n      var db = b - (colorTab[i] & 0xff);\n      var d = dr * dr + dg * dg + db * db;\n      var index = i / 3;\n\n      if (usedEntry[index] && d < dmin) {\n        dmin = d;\n        minpos = index;\n      }\n\n      i++;\n    }\n\n    return minpos;\n  };\n  /**\r\n   * Extracts image pixels into byte array \"pixels\r\n   */\n\n\n  var getImagePixels = function getImagePixels() {\n    var w = width;\n    var h = height;\n    pixels = [];\n    var data = image;\n    var count = 0;\n\n    for (var i = 0; i < h; i++) {\n      for (var j = 0; j < w; j++) {\n        var b = i * w * 4 + j * 4;\n        pixels[count++] = data[b];\n        pixels[count++] = data[b + 1];\n        pixels[count++] = data[b + 2];\n      }\n    }\n  };\n  /**\r\n   * Writes Graphic Control Extension\r\n   */\n\n\n  var writeGraphicCtrlExt = function writeGraphicCtrlExt() {\n    out.writeByte(0x21); // extension introducer\n\n    out.writeByte(0xf9); // GCE label\n\n    out.writeByte(4); // data block size\n\n    var transp;\n    var disp;\n\n    if (transparent === null) {\n      transp = 0;\n      disp = 0; // dispose = no action\n    } else {\n      transp = 1;\n      disp = 2; // force clear if using transparent color\n    }\n\n    if (dispose >= 0) {\n      disp = dispose & 7; // user override\n    }\n\n    disp <<= 2; // packed fields\n\n    out.writeByte(0 | // 1:3 reserved\n    disp | // 4:6 disposal\n    0 | // 7 user input - 0 = none\n    transp); // 8 transparency flag\n\n    WriteShort(delay); // delay x 1/100 sec\n\n    out.writeByte(transIndex); // transparent color index\n\n    out.writeByte(0); // block terminator\n  };\n  /**\r\n   * Writes Comment Extention\r\n   */\n\n\n  var writeCommentExt = function writeCommentExt() {\n    out.writeByte(0x21); // extension introducer\n\n    out.writeByte(0xfe); // comment label\n\n    out.writeByte(comment.length); // Block Size (s)\n\n    out.writeUTFBytes(comment);\n    out.writeByte(0); // block terminator\n  };\n  /**\r\n   * Writes Image Descriptor\r\n   */\n\n\n  var writeImageDesc = function writeImageDesc() {\n    out.writeByte(0x2c); // image separator\n\n    WriteShort(0); // image position x,y = 0,0\n\n    WriteShort(0);\n    WriteShort(width); // image size\n\n    WriteShort(height); // packed fields\n\n    if (firstFrame) {\n      // no LCT - GCT is used for first (or only) frame\n      out.writeByte(0);\n    } else {\n      // specify normal LCT\n      out.writeByte(0x80 | // 1 local color table 1=yes\n      0 | // 2 interlace - 0=no\n      0 | // 3 sorted - 0=no\n      0 | // 4-5 reserved\n      palSize); // 6-8 size of color table\n    }\n  };\n  /**\r\n   * Writes Logical Screen Descriptor\r\n   */\n\n\n  var writeLSD = function writeLSD() {\n    // logical screen size\n    WriteShort(width);\n    WriteShort(height); // packed fields\n\n    out.writeByte(0x80 | // 1 : global color table flag = 1 (gct used)\n    0x70 | // 2-4 : color resolution = 7\n    0x00 | // 5 : gct sort flag = 0\n    palSize); // 6-8 : gct size\n\n    out.writeByte(0); // background color index\n\n    out.writeByte(0); // pixel aspect ratio - assume 1:1\n  };\n  /**\r\n   * Writes Netscape application extension to define repeat count.\r\n   */\n\n\n  var writeNetscapeExt = function writeNetscapeExt() {\n    out.writeByte(0x21); // extension introducer\n\n    out.writeByte(0xff); // app extension label\n\n    out.writeByte(11); // block size\n\n    out.writeUTFBytes('NETSCAPE' + '2.0'); // app id + auth code\n\n    out.writeByte(3); // sub-block size\n\n    out.writeByte(1); // loop sub-block id\n\n    WriteShort(repeat); // loop count (extra iterations, 0=repeat forever)\n\n    out.writeByte(0); // block terminator\n  };\n  /**\r\n   * Writes color table\r\n   */\n\n\n  var writePalette = function writePalette() {\n    out.writeBytes(colorTab);\n    var n = 3 * 256 - colorTab.length;\n\n    for (var i = 0; i < n; i++) out.writeByte(0);\n  };\n\n  var WriteShort = function WriteShort(pValue) {\n    out.writeByte(pValue & 0xFF);\n    out.writeByte(pValue >> 8 & 0xFF);\n  };\n  /**\r\n   * Encodes and writes pixel data\r\n   */\n\n\n  var writePixels = function writePixels() {\n    var myencoder = new LZWEncoder(width, height, indexedPixels, colorDepth);\n    myencoder.encode(out);\n  };\n  /**\r\n   * Retrieves the GIF stream\r\n   */\n\n\n  var stream = exports.stream = function stream() {\n    return out;\n  };\n\n  var setProperties = exports.setProperties = function setProperties(has_start, is_first) {\n    started = has_start;\n    firstFrame = is_first;\n  };\n\n  return exports;\n};"},function(n,e,t){t(0)(t(9))},function(n,e){n.exports="/**\r\n * This class handles LZW encoding\r\n * Adapted from Jef Poskanzer's Java port by way of J. M. G. Elliott.\r\n * @author Kevin Weiner (original Java version - kweiner@fmsware.com)\r\n * @author Thibault Imbert (AS3 version - bytearray.org)\r\n * @author Kevin Kwok (JavaScript version - https://github.com/antimatter15/jsgif)\r\n * @version 0.1 AS3 implementation\r\n */\nLZWEncoder = function () {\n  var exports = {};\n  var EOF = -1;\n  var imgW;\n  var imgH;\n  var pixAry;\n  var initCodeSize;\n  var remaining;\n  var curPixel; // GIFCOMPR.C - GIF Image compression routines\n  // Lempel-Ziv compression based on 'compress'. GIF modifications by\n  // David Rowley (mgardi@watdcsu.waterloo.edu)\n  // General DEFINEs\n\n  var BITS = 12;\n  var HSIZE = 5003; // 80% occupancy\n  // GIF Image compression - modified 'compress'\n  // Based on: compress.c - File compression ala IEEE Computer, June 1984.\n  // By Authors: Spencer W. Thomas (decvax!harpo!utah-cs!utah-gr!thomas)\n  // Jim McKie (decvax!mcvax!jim)\n  // Steve Davies (decvax!vax135!petsd!peora!srd)\n  // Ken Turkowski (decvax!decwrl!turtlevax!ken)\n  // James A. Woods (decvax!ihnp4!ames!jaw)\n  // Joe Orost (decvax!vax135!petsd!joe)\n\n  var n_bits; // number of bits/code\n\n  var maxbits = BITS; // user settable max # bits/code\n\n  var maxcode; // maximum code, given n_bits\n\n  var maxmaxcode = 1 << BITS; // should NEVER generate this code\n\n  var htab = [];\n  var codetab = [];\n  var hsize = HSIZE; // for dynamic table sizing\n\n  var free_ent = 0; // first unused entry\n  // block compression parameters -- after all codes are used up,\n  // and compression rate changes, start over.\n\n  var clear_flg = false; // Algorithm: use open addressing double hashing (no chaining) on the\n  // prefix code / next character combination. We do a variant of Knuth's\n  // algorithm D (vol. 3, sec. 6.4) along with G. Knott's relatively-prime\n  // secondary probe. Here, the modular division first probe is gives way\n  // to a faster exclusive-or manipulation. Also do block compression with\n  // an adaptive reset, whereby the code table is cleared when the compression\n  // ratio decreases, but after the table fills. The variable-length output\n  // codes are re-sized at this point, and a special CLEAR code is generated\n  // for the decompressor. Late addition: construct the table according to\n  // file size for noticeable speed improvement on small files. Please direct\n  // questions about this implementation to ames!jaw.\n\n  var g_init_bits;\n  var ClearCode;\n  var EOFCode; // output\n  // Output the given code.\n  // Inputs:\n  // code: A n_bits-bit integer. If == -1, then EOF. This assumes\n  // that n_bits =< wordsize - 1.\n  // Outputs:\n  // Outputs code to the file.\n  // Assumptions:\n  // Chars are 8 bits long.\n  // Algorithm:\n  // Maintain a BITS character long buffer (so that 8 codes will\n  // fit in it exactly). Use the VAX insv instruction to insert each\n  // code in turn. When the buffer fills up empty it and start over.\n\n  var cur_accum = 0;\n  var cur_bits = 0;\n  var masks = [0x0000, 0x0001, 0x0003, 0x0007, 0x000F, 0x001F, 0x003F, 0x007F, 0x00FF, 0x01FF, 0x03FF, 0x07FF, 0x0FFF, 0x1FFF, 0x3FFF, 0x7FFF, 0xFFFF]; // Number of characters so far in this 'packet'\n\n  var a_count; // Define the storage for the packet accumulator\n\n  var accum = [];\n\n  var LZWEncoder = exports.LZWEncoder = function LZWEncoder(width, height, pixels, color_depth) {\n    imgW = width;\n    imgH = height;\n    pixAry = pixels;\n    initCodeSize = Math.max(2, color_depth);\n  }; // Add a character to the end of the current packet, and if it is 254\n  // characters, flush the packet to disk.\n\n\n  var char_out = function char_out(c, outs) {\n    accum[a_count++] = c;\n    if (a_count >= 254) flush_char(outs);\n  }; // Clear out the hash table\n  // table clear for block compress\n\n\n  var cl_block = function cl_block(outs) {\n    cl_hash(hsize);\n    free_ent = ClearCode + 2;\n    clear_flg = true;\n    output(ClearCode, outs);\n  }; // reset code table\n\n\n  var cl_hash = function cl_hash(hsize) {\n    for (var i = 0; i < hsize; ++i) htab[i] = -1;\n  };\n\n  var compress = exports.compress = function compress(init_bits, outs) {\n    var fcode;\n    var i;\n    /* = 0 */\n\n    var c;\n    var ent;\n    var disp;\n    var hsize_reg;\n    var hshift; // Set up the globals: g_init_bits - initial number of bits\n\n    g_init_bits = init_bits; // Set up the necessary values\n\n    clear_flg = false;\n    n_bits = g_init_bits;\n    maxcode = MAXCODE(n_bits);\n    ClearCode = 1 << init_bits - 1;\n    EOFCode = ClearCode + 1;\n    free_ent = ClearCode + 2;\n    a_count = 0; // clear packet\n\n    ent = nextPixel();\n    hshift = 0;\n\n    for (fcode = hsize; fcode < 65536; fcode *= 2) ++hshift;\n\n    hshift = 8 - hshift; // set hash code range bound\n\n    hsize_reg = hsize;\n    cl_hash(hsize_reg); // clear hash table\n\n    output(ClearCode, outs);\n\n    outer_loop: while ((c = nextPixel()) != EOF) {\n      fcode = (c << maxbits) + ent;\n      i = c << hshift ^ ent; // xor hashing\n\n      if (htab[i] == fcode) {\n        ent = codetab[i];\n        continue;\n      } else if (htab[i] >= 0) {\n        // non-empty slot\n        disp = hsize_reg - i; // secondary hash (after G. Knott)\n\n        if (i === 0) disp = 1;\n\n        do {\n          if ((i -= disp) < 0) i += hsize_reg;\n\n          if (htab[i] == fcode) {\n            ent = codetab[i];\n            continue outer_loop;\n          }\n        } while (htab[i] >= 0);\n      }\n\n      output(ent, outs);\n      ent = c;\n\n      if (free_ent < maxmaxcode) {\n        codetab[i] = free_ent++; // code -> hashtable\n\n        htab[i] = fcode;\n      } else cl_block(outs);\n    } // Put out the final code.\n\n\n    output(ent, outs);\n    output(EOFCode, outs);\n  }; // ----------------------------------------------------------------------------\n\n\n  var encode = exports.encode = function encode(os) {\n    os.writeByte(initCodeSize); // write \"initial code size\" byte\n\n    remaining = imgW * imgH; // reset navigation variables\n\n    curPixel = 0;\n    compress(initCodeSize + 1, os); // compress and write the pixel data\n\n    os.writeByte(0); // write block terminator\n  }; // Flush the packet to disk, and reset the accumulator\n\n\n  var flush_char = function flush_char(outs) {\n    if (a_count > 0) {\n      outs.writeByte(a_count);\n      outs.writeBytes(accum, 0, a_count);\n      a_count = 0;\n    }\n  };\n\n  var MAXCODE = function MAXCODE(n_bits) {\n    return (1 << n_bits) - 1;\n  }; // ----------------------------------------------------------------------------\n  // Return the next pixel from the image\n  // ----------------------------------------------------------------------------\n\n\n  var nextPixel = function nextPixel() {\n    if (remaining === 0) return EOF;\n    --remaining;\n    var pix = pixAry[curPixel++];\n    return pix & 0xff;\n  };\n\n  var output = function output(code, outs) {\n    cur_accum &= masks[cur_bits];\n    if (cur_bits > 0) cur_accum |= code << cur_bits;else cur_accum = code;\n    cur_bits += n_bits;\n\n    while (cur_bits >= 8) {\n      char_out(cur_accum & 0xff, outs);\n      cur_accum >>= 8;\n      cur_bits -= 8;\n    } // If the next entry is going to be too big for the code size,\n    // then increase it, if possible.\n\n\n    if (free_ent > maxcode || clear_flg) {\n      if (clear_flg) {\n        maxcode = MAXCODE(n_bits = g_init_bits);\n        clear_flg = false;\n      } else {\n        ++n_bits;\n        if (n_bits == maxbits) maxcode = maxmaxcode;else maxcode = MAXCODE(n_bits);\n      }\n    }\n\n    if (code == EOFCode) {\n      // At EOF, write the rest of the buffer.\n      while (cur_bits > 0) {\n        char_out(cur_accum & 0xff, outs);\n        cur_accum >>= 8;\n        cur_bits -= 8;\n      }\n\n      flush_char(outs);\n    }\n  };\n\n  LZWEncoder.apply(this, arguments);\n  return exports;\n};"},function(n,e,t){t(0)(t(11))},function(n,e){n.exports='/*\r\n * NeuQuant Neural-Net Quantization Algorithm\r\n * ------------------------------------------\r\n *\r\n * Copyright (c) 1994 Anthony Dekker\r\n *\r\n * NEUQUANT Neural-Net quantization algorithm by Anthony Dekker, 1994. See\r\n * "Kohonen neural networks for optimal colour quantization" in "Network:\r\n * Computation in Neural Systems" Vol. 5 (1994) pp 351-367. for a discussion of\r\n * the algorithm.\r\n *\r\n * Any party obtaining a copy of these files from the author, directly or\r\n * indirectly, is granted, free of charge, a full and unrestricted irrevocable,\r\n * world-wide, paid up, royalty-free, nonexclusive right and license to deal in\r\n * this software and documentation files (the "Software"), including without\r\n * limitation the rights to use, copy, modify, merge, publish, distribute,\r\n * sublicense, and/or sell copies of the Software, and to permit persons who\r\n * receive copies from any such party to do so, with the only requirement being\r\n * that this copyright notice remain intact.\r\n */\n\n/*\r\n * This class handles Neural-Net quantization algorithm\r\n * @author Kevin Weiner (original Java version - kweiner@fmsware.com)\r\n * @author Thibault Imbert (AS3 version - bytearray.org)\r\n * @author Kevin Kwok (JavaScript version - https://github.com/antimatter15/jsgif)\r\n * @version 0.1 AS3 implementation\r\n */\nNeuQuant = function () {\n  var exports = {};\n  var netsize = 256;\n  /* number of colours used */\n\n  /* four primes near 500 - assume no image has a length so large */\n\n  /* that it is divisible by all four primes */\n\n  var prime1 = 499;\n  var prime2 = 491;\n  var prime3 = 487;\n  var prime4 = 503;\n  var minpicturebytes = 3 * prime4;\n  /* minimum size for input image */\n\n  /*\r\n   * Program Skeleton ---------------- [select samplefac in range 1..30] [read\r\n   * image from input file] pic = (unsigned char*) malloc(3*width*height);\r\n   * initnet(pic,3*width*height,samplefac); learn(); unbiasnet(); [write output\r\n   * image header, using writecolourmap(f)] inxbuild(); write output image using\r\n   * inxsearch(b,g,r)\r\n   */\n\n  /*\r\n   * Network Definitions -------------------\r\n   */\n\n  var maxnetpos = netsize - 1;\n  var netbiasshift = 4;\n  /* bias for colour values */\n\n  var ncycles = 100;\n  /* no. of learning cycles */\n\n  /* defs for freq and bias */\n\n  var intbiasshift = 16;\n  /* bias for fractions */\n\n  var intbias = 1 << intbiasshift;\n  var gammashift = 10;\n  /* gamma = 1024 */\n\n  var gamma = 1 << gammashift;\n  var betashift = 10;\n  var beta = intbias >> betashift;\n  /* beta = 1/1024 */\n\n  var betagamma = intbias << gammashift - betashift;\n  /* defs for decreasing radius factor */\n\n  var initrad = netsize >> 3;\n  /* for 256 cols, radius starts */\n\n  var radiusbiasshift = 6;\n  /* at 32.0 biased by 6 bits */\n\n  var radiusbias = 1 << radiusbiasshift;\n  var initradius = initrad * radiusbias;\n  /* and decreases by a */\n\n  var radiusdec = 30;\n  /* factor of 1/30 each cycle */\n\n  /* defs for decreasing alpha factor */\n\n  var alphabiasshift = 10;\n  /* alpha starts at 1.0 */\n\n  var initalpha = 1 << alphabiasshift;\n  var alphadec;\n  /* biased by 10 bits */\n\n  /* radbias and alpharadbias used for radpower calculation */\n\n  var radbiasshift = 8;\n  var radbias = 1 << radbiasshift;\n  var alpharadbshift = alphabiasshift + radbiasshift;\n  var alpharadbias = 1 << alpharadbshift;\n  /*\r\n   * Types and Global Variables --------------------------\r\n   */\n\n  var thepicture;\n  /* the input image itself */\n\n  var lengthcount;\n  /* lengthcount = H*W*3 */\n\n  var samplefac;\n  /* sampling factor 1..30 */\n  // typedef int pixel[4]; /* BGRc */\n\n  var network;\n  /* the network itself - [netsize][4] */\n\n  var netindex = [];\n  /* for network lookup - really 256 */\n\n  var bias = [];\n  /* bias and freq arrays for learning */\n\n  var freq = [];\n  var radpower = [];\n\n  var NeuQuant = exports.NeuQuant = function NeuQuant(thepic, len, sample) {\n    var i;\n    var p;\n    thepicture = thepic;\n    lengthcount = len;\n    samplefac = sample;\n    network = new Array(netsize);\n\n    for (i = 0; i < netsize; i++) {\n      network[i] = new Array(4);\n      p = network[i];\n      p[0] = p[1] = p[2] = (i << netbiasshift + 8) / netsize;\n      freq[i] = intbias / netsize;\n      /* 1/netsize */\n\n      bias[i] = 0;\n    }\n  };\n\n  var colorMap = function colorMap() {\n    var map = [];\n    var index = new Array(netsize);\n\n    for (var i = 0; i < netsize; i++) index[network[i][3]] = i;\n\n    var k = 0;\n\n    for (var l = 0; l < netsize; l++) {\n      var j = index[l];\n      map[k++] = network[j][0];\n      map[k++] = network[j][1];\n      map[k++] = network[j][2];\n    }\n\n    return map;\n  };\n  /*\r\n   * Insertion sort of network and building of netindex[0..255] (to do after\r\n   * unbias)\r\n   * -------------------------------------------------------------------------------\r\n   */\n\n\n  var inxbuild = function inxbuild() {\n    var i;\n    var j;\n    var smallpos;\n    var smallval;\n    var p;\n    var q;\n    var previouscol;\n    var startpos;\n    previouscol = 0;\n    startpos = 0;\n\n    for (i = 0; i < netsize; i++) {\n      p = network[i];\n      smallpos = i;\n      smallval = p[1];\n      /* index on g */\n\n      /* find smallest in i..netsize-1 */\n\n      for (j = i + 1; j < netsize; j++) {\n        q = network[j];\n\n        if (q[1] < smallval) {\n          /* index on g */\n          smallpos = j;\n          smallval = q[1];\n          /* index on g */\n        }\n      }\n\n      q = network[smallpos];\n      /* swap p (i) and q (smallpos) entries */\n\n      if (i != smallpos) {\n        j = q[0];\n        q[0] = p[0];\n        p[0] = j;\n        j = q[1];\n        q[1] = p[1];\n        p[1] = j;\n        j = q[2];\n        q[2] = p[2];\n        p[2] = j;\n        j = q[3];\n        q[3] = p[3];\n        p[3] = j;\n      }\n      /* smallval entry is now in position i */\n\n\n      if (smallval != previouscol) {\n        netindex[previouscol] = startpos + i >> 1;\n\n        for (j = previouscol + 1; j < smallval; j++) netindex[j] = i;\n\n        previouscol = smallval;\n        startpos = i;\n      }\n    }\n\n    netindex[previouscol] = startpos + maxnetpos >> 1;\n\n    for (j = previouscol + 1; j < 256; j++) netindex[j] = maxnetpos;\n    /* really 256 */\n\n  };\n  /*\r\n   * Main Learning Loop ------------------\r\n   */\n\n\n  var learn = function learn() {\n    var i;\n    var j;\n    var b;\n    var g;\n    var r;\n    var radius;\n    var rad;\n    var alpha;\n    var step;\n    var delta;\n    var samplepixels;\n    var p;\n    var pix;\n    var lim;\n    if (lengthcount < minpicturebytes) samplefac = 1;\n    alphadec = 30 + (samplefac - 1) / 3;\n    p = thepicture;\n    pix = 0;\n    lim = lengthcount;\n    samplepixels = lengthcount / (3 * samplefac);\n    delta = samplepixels / ncycles | 0;\n    alpha = initalpha;\n    radius = initradius;\n    rad = radius >> radiusbiasshift;\n    if (rad <= 1) rad = 0;\n\n    for (i = 0; i < rad; i++) radpower[i] = alpha * ((rad * rad - i * i) * radbias / (rad * rad));\n\n    if (lengthcount < minpicturebytes) step = 3;else if (lengthcount % prime1 !== 0) step = 3 * prime1;else {\n      if (lengthcount % prime2 !== 0) step = 3 * prime2;else {\n        if (lengthcount % prime3 !== 0) step = 3 * prime3;else step = 3 * prime4;\n      }\n    }\n    i = 0;\n\n    while (i < samplepixels) {\n      b = (p[pix + 0] & 0xff) << netbiasshift;\n      g = (p[pix + 1] & 0xff) << netbiasshift;\n      r = (p[pix + 2] & 0xff) << netbiasshift;\n      j = contest(b, g, r);\n      altersingle(alpha, j, b, g, r);\n      if (rad !== 0) alterneigh(rad, j, b, g, r);\n      /* alter neighbours */\n\n      pix += step;\n      if (pix >= lim) pix -= lengthcount;\n      i++;\n      if (delta === 0) delta = 1;\n\n      if (i % delta === 0) {\n        alpha -= alpha / alphadec;\n        radius -= radius / radiusdec;\n        rad = radius >> radiusbiasshift;\n        if (rad <= 1) rad = 0;\n\n        for (j = 0; j < rad; j++) radpower[j] = alpha * ((rad * rad - j * j) * radbias / (rad * rad));\n      }\n    }\n  };\n  /*\r\n   ** Search for BGR values 0..255 (after net is unbiased) and return colour\r\n   * index\r\n   * ----------------------------------------------------------------------------\r\n   */\n\n\n  var map = exports.map = function map(b, g, r) {\n    var i;\n    var j;\n    var dist;\n    var a;\n    var bestd;\n    var p;\n    var best;\n    bestd = 1000;\n    /* biggest possible dist is 256*3 */\n\n    best = -1;\n    i = netindex[g];\n    /* index on g */\n\n    j = i - 1;\n    /* start at netindex[g] and work outwards */\n\n    while (i < netsize || j >= 0) {\n      if (i < netsize) {\n        p = network[i];\n        dist = p[1] - g;\n        /* inx key */\n\n        if (dist >= bestd) i = netsize;\n        /* stop iter */\n        else {\n            i++;\n            if (dist < 0) dist = -dist;\n            a = p[0] - b;\n            if (a < 0) a = -a;\n            dist += a;\n\n            if (dist < bestd) {\n              a = p[2] - r;\n              if (a < 0) a = -a;\n              dist += a;\n\n              if (dist < bestd) {\n                bestd = dist;\n                best = p[3];\n              }\n            }\n          }\n      }\n\n      if (j >= 0) {\n        p = network[j];\n        dist = g - p[1];\n        /* inx key - reverse dif */\n\n        if (dist >= bestd) j = -1;\n        /* stop iter */\n        else {\n            j--;\n            if (dist < 0) dist = -dist;\n            a = p[0] - b;\n            if (a < 0) a = -a;\n            dist += a;\n\n            if (dist < bestd) {\n              a = p[2] - r;\n              if (a < 0) a = -a;\n              dist += a;\n\n              if (dist < bestd) {\n                bestd = dist;\n                best = p[3];\n              }\n            }\n          }\n      }\n    }\n\n    return best;\n  };\n\n  var process = exports.process = function process() {\n    learn();\n    unbiasnet();\n    inxbuild();\n    return colorMap();\n  };\n  /*\r\n   * Unbias network to give byte values 0..255 and record position i to prepare\r\n   * for sort\r\n   * -----------------------------------------------------------------------------------\r\n   */\n\n\n  var unbiasnet = function unbiasnet() {\n    var i;\n    var j;\n\n    for (i = 0; i < netsize; i++) {\n      network[i][0] >>= netbiasshift;\n      network[i][1] >>= netbiasshift;\n      network[i][2] >>= netbiasshift;\n      network[i][3] = i;\n      /* record colour no */\n    }\n  };\n  /*\r\n   * Move adjacent neurons by precomputed alpha*(1-((i-j)^2/[r]^2)) in\r\n   * radpower[|i-j|]\r\n   * ---------------------------------------------------------------------------------\r\n   */\n\n\n  var alterneigh = function alterneigh(rad, i, b, g, r) {\n    var j;\n    var k;\n    var lo;\n    var hi;\n    var a;\n    var m;\n    var p;\n    lo = i - rad;\n    if (lo < -1) lo = -1;\n    hi = i + rad;\n    if (hi > netsize) hi = netsize;\n    j = i + 1;\n    k = i - 1;\n    m = 1;\n\n    while (j < hi || k > lo) {\n      a = radpower[m++];\n\n      if (j < hi) {\n        p = network[j++];\n\n        try {\n          p[0] -= a * (p[0] - b) / alpharadbias;\n          p[1] -= a * (p[1] - g) / alpharadbias;\n          p[2] -= a * (p[2] - r) / alpharadbias;\n        } catch (e) {} // prevents 1.3 miscompilation\n\n      }\n\n      if (k > lo) {\n        p = network[k--];\n\n        try {\n          p[0] -= a * (p[0] - b) / alpharadbias;\n          p[1] -= a * (p[1] - g) / alpharadbias;\n          p[2] -= a * (p[2] - r) / alpharadbias;\n        } catch (e) {}\n      }\n    }\n  };\n  /*\r\n   * Move neuron i towards biased (b,g,r) by factor alpha\r\n   * ----------------------------------------------------\r\n   */\n\n\n  var altersingle = function altersingle(alpha, i, b, g, r) {\n    /* alter hit neuron */\n    var n = network[i];\n    n[0] -= alpha * (n[0] - b) / initalpha;\n    n[1] -= alpha * (n[1] - g) / initalpha;\n    n[2] -= alpha * (n[2] - r) / initalpha;\n  };\n  /*\r\n   * Search for biased BGR values ----------------------------\r\n   */\n\n\n  var contest = function contest(b, g, r) {\n    /* finds closest neuron (min dist) and updates freq */\n\n    /* finds best neuron (min dist-bias) and returns position */\n\n    /* for frequently chosen neurons, freq[i] is high and bias[i] is negative */\n\n    /* bias[i] = gamma*((1/netsize)-freq[i]) */\n    var i;\n    var dist;\n    var a;\n    var biasdist;\n    var betafreq;\n    var bestpos;\n    var bestbiaspos;\n    var bestd;\n    var bestbiasd;\n    var n;\n    bestd = ~(1 << 31);\n    bestbiasd = bestd;\n    bestpos = -1;\n    bestbiaspos = bestpos;\n\n    for (i = 0; i < netsize; i++) {\n      n = network[i];\n      dist = n[0] - b;\n      if (dist < 0) dist = -dist;\n      a = n[1] - g;\n      if (a < 0) a = -a;\n      dist += a;\n      a = n[2] - r;\n      if (a < 0) a = -a;\n      dist += a;\n\n      if (dist < bestd) {\n        bestd = dist;\n        bestpos = i;\n      }\n\n      biasdist = dist - (bias[i] >> intbiasshift - netbiasshift);\n\n      if (biasdist < bestbiasd) {\n        bestbiasd = biasdist;\n        bestbiaspos = i;\n      }\n\n      betafreq = freq[i] >> betashift;\n      freq[i] -= betafreq;\n      bias[i] += betafreq << gammashift;\n    }\n\n    freq[bestpos] += beta;\n    bias[bestpos] -= betagamma;\n    return bestbiaspos;\n  };\n\n  NeuQuant.apply(this, arguments);\n  return exports;\n};'},function(n,e,t){t(0)(t(13))},function(n,e){n.exports='function encode64(input) {\n  var output = "",\n      i = 0,\n      l = input.length,\n      key = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",\n      chr1,\n      chr2,\n      chr3,\n      enc1,\n      enc2,\n      enc3,\n      enc4;\n\n  while (i < l) {\n    chr1 = input.charCodeAt(i++);\n    chr2 = input.charCodeAt(i++);\n    chr3 = input.charCodeAt(i++);\n    enc1 = chr1 >> 2;\n    enc2 = (chr1 & 3) << 4 | chr2 >> 4;\n    enc3 = (chr2 & 15) << 2 | chr3 >> 6;\n    enc4 = chr3 & 63;\n    if (isNaN(chr2)) enc3 = enc4 = 64;else if (isNaN(chr3)) enc4 = 64;\n    output = output + key.charAt(enc1) + key.charAt(enc2) + key.charAt(enc3) + key.charAt(enc4);\n  }\n\n  return output;\n}'},function(n,e,t){"use strict";t.r(e);t(1);class r{constructor(n){this.objData=n,this.draw=!0,this.imageData=this.objData.context.createImageData(1,1)}mousedown(n){n.mouse.x=(n.event.pageX-n.canvas.offsetLeft+n.offsetScale)/n.speedMouse,n.mouse.y=(n.event.pageY-n.canvas.offsetTop+n.offsetScale)/n.speedMouse,this.imageData.data[0]=n.color[0],this.imageData.data[1]=n.color[1],this.imageData.data[2]=n.color[2],this.imageData.data[3]=255,n.context.putImageData(this.imageData,n.mouse.x,n.mouse.y)}mousemove(n){this.objData.mouse.x=(n.pageX-this.objData.canvas.offsetLeft+this.objData.offsetScale)/this.objData.speedMouse,this.objData.mouse.y=(n.pageY-this.objData.canvas.offsetTop+this.objData.offsetScale)/this.objData.speedMouse,!0===this.draw&&this.objData.context.putImageData(this.imageData,this.objData.mouse.x,this.objData.mouse.y)}}class a{constructor(n){this.erase=!0,this.objData=n}mousedown(n){n.mouse.x=n.event.pageX-n.canvas.offsetLeft+n.offsetScale,n.mouse.y=n.event.pageY-n.canvas.offsetTop+n.offsetScale,this.objData.context.clearRect(n.mouse.x/n.speedMouse,n.mouse.y/n.speedMouse,1,1)}mousemove(n){this.objData.mouse.x=(n.pageX-this.objData.canvas.offsetLeft+this.objData.offsetScale)/this.objData.speedMouse,this.objData.mouse.y=(n.pageY-this.objData.canvas.offsetTop+this.objData.offsetScale)/this.objData.speedMouse,!0===this.erase&&this.objData.context.clearRect(this.objData.mouse.x,this.objData.mouse.y,1,1)}}class i{constructor(n){this.width=n.canvas.width,this.height=n.canvas.height,this.imageData=n.context.getImageData(0,0,this.width,this.height)}fill(n){const e=((e,t)=>{const r=t%n.speedMouse,a=e%n.speedMouse,i=(t-r)/n.speedMouse;return{X:(e-a)/n.speedMouse,Y:i}})(n.event.pageX-n.canvas.offsetLeft+n.offsetScale,n.event.pageY-n.canvas.offsetTop+n.offsetScale),t=e.Y,r=e.X,a=[[r,t]],i=n.context.getImageData(r,t,1,1),s=i.data[0],o=i.data[1],l=i.data[2];if(255===i.data[3]&&"allPixelsColor"===n.nameTool)for(let e=0;e<this.imageData.data.length;e+=4)255===this.imageData.data[e+3]&&(this.imageData.data[e+0]=n.color[0],this.imageData.data[e+1]=n.color[1],this.imageData.data[e+2]=n.color[2]);const c=n=>{const e=this.imageData.data[n],t=this.imageData.data[n+1],r=this.imageData.data[n+2];return e===s&&t===o&&r===l},d=e=>{this.imageData.data[e]=n.color[0],this.imageData.data[e+1]=n.color[1],this.imageData.data[e+2]=n.color[2],this.imageData.data[e+3]=255};if(s!==n.color[0]||o!==n.color[1]||l!==n.color[2]){for(;a.length;){const n=a.pop(),e=n[0];let t=n[1],r=4*(t*this.width+e);for(;t-- >=0&&c(r);)r-=4*this.width;r+=4*this.width,++t;let i=!1,s=!1;for(;t++<this.height-1&&c(r);)d(r),e>0&&(c(r-4)?i||(a.push([e-1,t]),i=!0):i&&(i=!1)),e<this.width-1&&(c(r+4)?s||(a.push([e+1,t]),s=!0):s&&(s=!1)),r+=4*this.width}n.context.putImageData(this.imageData,0,0),n.previewContext.src=n.canvas.toDataURL()}}}class s{constructor(n){this.line=!0,this.objData=n,this.newCoord="",this.setPixel=((e,t,r)=>{const a=n.auxiliaryContext.createImageData(1,1);a.data[0]=r.r,a.data[1]=r.g,a.data[2]=r.b,a.data[3]=r.a,n.auxiliaryContext.putImageData(a,e,t)}),this.drawLine=((n,e,t,r,a)=>{const i=Math.abs(t-n),s=Math.abs(r-e),o=n<t?1:-1,l=e<r?1:-1;let c=i-s;for(this.setPixel(t,r,a);n!=t||e!=r;){this.setPixel(n,e,a);const t=2*c;t>-s&&(c-=s,n+=o),t<i&&(c+=i,e+=l)}}),this.calcCoord=((n,e)=>{const t=e%this.objData.speedMouse,r=n%this.objData.speedMouse,a=(e-t)/this.objData.speedMouse;return{X:(n-r)/this.objData.speedMouse,Y:a}})}mousedown(n){this.lineDraw=!0;const e=n.pageX-this.objData.auxiliaryCanvas.offsetLeft+this.objData.offsetScale,t=n.pageY-this.objData.auxiliaryCanvas.offsetTop+this.objData.offsetScale;this.newCoord=this.calcCoord(e,t),this.setPixel(this.newCoord.X,this.newCoord.Y,{r:this.objData.color[0],g:this.objData.color[1],b:this.objData.color[2],a:255})}mousemove(n){const e=n.pageX-this.objData.auxiliaryCanvas.offsetLeft+this.objData.offsetScale,t=n.pageY-this.objData.auxiliaryCanvas.offsetTop+this.objData.offsetScale,r=this.calcCoord(e,t);!0===this.lineDraw&&(this.objData.auxiliaryContext.clearRect(0,0,this.objData.auxiliaryCanvas.width,this.objData.auxiliaryCanvas.height),this.objData.auxiliaryContext.drawImage(this.objData.canvas,0,0),this.drawLine(this.newCoord.X,this.newCoord.Y,r.X,r.Y,{r:this.objData.color[0],g:this.objData.color[1],b:this.objData.color[2],a:255}))}mouseup(){this.objData.context.drawImage(this.objData.auxiliaryCanvas,0,0),this.lineDraw=!1}}t(6),t(8),t(10),t(12);const o=new class{constructor(){this.download=document.getElementById("download"),this.state={currentTool:""},this.menu=document.getElementsByClassName("menu"),this.pen=document.getElementById("pen"),this.eraser=document.getElementById("eraser"),this.allPixelsColor=document.getElementById("allPixelsColor"),this.straightLine=document.getElementById("straightLine"),this.buttonSettings=document.getElementsByClassName("buttonSettings")[0],this.settings=document.getElementsByClassName("settings")[0],this.newCanvas=document.getElementById("myCanvas"),this.auxiliaryCanvas=document.getElementById("auxiliaryCanvas"),this.auxiliaryContext=this.auxiliaryCanvas.getContext("2d"),this.preview=document.getElementById("preview"),this.grid=document.getElementById("grid"),this.paintBucket=document.getElementById("paintBucket"),this.context=this.newCanvas.getContext("2d"),this.context.fillStyle="#e3e3e3",this.context.fillRect(0,0,this.newCanvas.width,this.newCanvas.height),this.mouse={x:0,y:0},this.primaryColor=document.getElementById("primaryColor"),this.secondaryColor=document.getElementById("secondaryColor"),this.paintBacket=document.getElementById("paintBucket"),this.resizeCanvas=document.getElementById("resize"),this.newCanvas.style.transform="matrix(28, 0, 0, 28, 0, 0)",this.auxiliaryCanvas.style.transform="matrix(28, 0, 0, 28, 0, 0)",this.auxiliaryCanvas.style.visibility="hidden",this.addFrame=document.getElementById("addFrameButton"),this.copyButton=document.getElementsByClassName("buttonCopy")[0],this.frames=document.getElementsByClassName("frames")[0],this.images=document.getElementsByClassName("image"),this.frame=document.getElementsByClassName("frame")}};let l,c,d,u,h,p,f,m,g=0,v=[230,100,101];const b={previewContext:o.preview,auxiliaryCanvas:o.auxiliaryCanvas,auxiliaryContext:o.auxiliaryContext,canvas:o.newCanvas,context:o.context,mouse:o.mouse,offsetScale:432,speedMouse:28,color:v,frames:o.frames,images:o.images,download:o.download},x=new class{constructor(n){this.id=0,this.signature="",this.defaultBackgroundFrame="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAL4AAAC+CAIAAAAEFiLKAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAHFSURBVHhe7dIxAQAADMOg+bdZI/OQGzRwg0QdInWI1CFSh0gdInWI1CFSh0gdInWI1CFSh0gdInWI1CFSh0gdInWI1CFSh0gdInWI1CFSh0gdInWI1CFSh0gdInWI1CFSh0gdInWI1CFSh0gdInWI1CFSh0gdInWI1CFSh0gdInWI1CFSh0gdInWI1CFSh0gdInWI1CFSh0gdInWI1CFSh0gdInWI1CFSh0gdInWI1CFSh0gdInWI1CFSh0gdInWI1CFSh0gdInWI1CFSh0gdInWI1CFSh0gdInWI1CFSh0gdInWI1CFSh0gdInWI1CFSh0gdInWI1CFSh0gdInWI1CFSh0gdInWI1CFSh0gdInWI1CFSh0gdInWI1CFSh0gdInWI1CFSh0gdInWI1CFSh0gdInWI1CFSh0gdInWI1CFSh0gdInWI1CFSh0gdInWI1CFSh0gdInWI1CFSh0gdInWI1CFSh0gdInWI1CFSh0gdInWI1CFSh0gdInWI1CFSh0gdInWI1CFSh0gdInWI1CFSh0gdInWI1CFSh0gdInWI1CFSh0gdInWI1CFSh0gdInWI1CFSh0gdInWI1CFSh0gdku0Bnhc1njj1szkAAAAASUVORK5CYII=",this.image="",this.deleteButton="",this.deleteButtonFirst=document.getElementById("0").children[2],this.deleteButtonFirst.addEventListener("click",e=>{const t=e.currentTarget.parentElement.nextElementSibling;if(n.children.length-1!=1){e.currentTarget.parentElement.classList.contains("active")&&t.classList.add("active"),e.currentTarget.parentElement.remove(),this.id--;for(let e=0;e<n.children.length-1;e=1)n.children[e].id=e,n.children[e].children[0].innerHTML=e}}),this.copyButton="",this.positionClick="",this.positionActive=""}addAndDelete(n){const e=document.getElementById(this.id),t=e.cloneNode(!0);this.image=t.getElementsByTagName("img")[0],this.image.src=this.defaultBackgroundFrame,this.signature=t.children[0],this.deleteButton=t.children[2],this.copyButton=t.children[3],t.id=this.id+1,this.signature.innerHTML=t.id;for(let e=0;e<n.children.length-1;e++)n.children[e].classList.remove("active");this.deleteButton.addEventListener("click",e=>{if(n.children.length-1==1)return;const t=e.currentTarget.parentElement.previousElementSibling,r=e.currentTarget.parentElement.nextElementSibling,a=e.currentTarget.parentElement;this.id--;for(let e=0;e<n.children.length-1;e++)n.children[e]===a&&(this.positionClick=e),n.children[e].classList.contains("active")&&(this.positionActive=e);if(this.positionActive===this.positionClick){0===this.positionActive?r.classList.add("active"):t.classList.add("active"),a.remove();for(let e=0;e<n.children.length-1;e++)n.children[e].id=e,n.children[e].children[0].innerHTML=e}if(this.positionActive<this.positionClick){a.remove();for(let e=0;e<n.children.length-1;e++)n.children[e].id=e,n.children[e].children[0].innerHTML=e}if(this.positionActive>this.positionClick){a.remove();for(let e=0;e<n.children.length-1;e++)n.children[e].id=e,n.children[e].children[0].innerHTML=e}}),t.classList.add("active"),e.parentNode.insertBefore(t,e.nextSibling),this.id++}}(b.frames),y=28,w=14,C=7;let k;const I=n=>{let e=n.match(/[A-Za-z0-9]{2}/g);return e=e.map(n=>parseInt(n,16))},S=()=>{p=b.canvas.toDataURL(),f=document.getElementsByClassName("active")[0],(m=f.getElementsByTagName("img")[0]).src=p};b.previewContext.src=x.defaultBackgroundFrame,b.frames.addEventListener("click",n=>{if(!("addFrameButton"===n.target.id||n.target.classList.contains("frames")||n.target.classList.contains("buttonDelete")||n.target.classList.contains("number")||n.target.classList.contains("buttonCopy")||n.target.classList.contains("fas"))){for(let n=0;n<o.frame.length;n++)o.frame[n].classList.remove("active");n.target.parentElement.classList.add("active"),b.context.clearRect(0,0,o.newCanvas.width,o.newCanvas.height),b.auxiliaryContext.clearRect(0,0,o.newCanvas.width,o.newCanvas.height),b.context.drawImage(n.target,0,0),b.auxiliaryContext.drawImage(n.target,0,0)}}),o.buttonSettings.addEventListener("click",()=>{"visible"===o.settings.style.visibility?o.settings.style.visibility="hidden":o.settings.style.visibility="visible"}),b.canvas.addEventListener("contextmenu",n=>{n.preventDefault()}),b.auxiliaryCanvas.addEventListener("contextmenu",n=>{n.preventDefault()}),o.resizeCanvas.addEventListener("change",n=>{let e;const t=o.context.getImageData(0,0,o.newCanvas.width,o.newCanvas.height);switch(b.canvas.width=n.target.value,b.canvas.height=n.target.value,b.auxiliaryCanvas.width=n.target.value,b.auxiliaryCanvas.height=n.target.value,b.context.putImageData(t,0,0),n.target.value){case"32":e=y,b.canvas.style.marginTop="455px",b.auxiliaryCanvas.style.marginTop="455px",b.auxiliaryCanvas.style.marginLeft="-32px",b.speedMouse=28,b.offsetScale=415;break;case"64":e=w,b.canvas.style.marginTop="439px",b.auxiliaryCanvas.style.marginTop="439px",b.auxiliaryCanvas.style.marginLeft="-64px",b.speedMouse=14,b.offsetScale=415;break;case"128":e=C,b.canvas.style.marginTop="407px",b.auxiliaryCanvas.style.marginTop="407px",b.auxiliaryCanvas.style.marginLeft="-128px",b.speedMouse=7,b.offsetScale=383}o.newCanvas.style.transform=`matrix(${e}, 0, 0, ${e}, 0, 0)`,o.auxiliaryCanvas.style.transform=`matrix(${e}, 0, 0, ${e}, 0, 0)`}),b.canvas.addEventListener("mousedown",n=>{switch(v=I(o.primaryColor.value),h=I(o.secondaryColor.value),b.event=n,b.color=v,b.nameTool=o.state.currentTool,3===n.which&&(b.color=h),b.nameTool){case"pen":(d=new r(b)).mousedown(b),k=d.mousemove,b.canvas.addEventListener("mousemove",k.bind(d)),document.addEventListener("mouseup",()=>{S(),b.canvas.removeEventListener("mousemove",k.bind(d)),d.draw=!1});break;case"eraser":(c=new a(b)).mousedown(b),k=c.mousemove,b.canvas.addEventListener("mousemove",k.bind(c)),document.addEventListener("mouseup",()=>{b.canvas.removeEventListener("mousemove",k.bind(c)),c.erase=!1});break;case"paintBucket":(u=new i(b)).fill(b),S();break;case"allPixelsColor":void 0===u&&(u=new i(b)),u.fill(b)}}),o.menu[0].addEventListener("click",n=>{switch(n.target){case o.pen:b.auxiliaryCanvas.style.visibility="hidden",o.eraser.style.border="",o.paintBacket.style.border="",o.allPixelsColor.style.border="",o.straightLine.style="",o.pen.style.border="3px solid red",o.state.currentTool="pen",b.canvas.style.cursor="url('src/screens/canvas/images/pen.cur'),auto";break;case o.eraser:b.auxiliaryCanvas.style.visibility="hidden",o.pen.style.border="",o.allPixelsColor.style.border="",o.paintBacket.style.border="",o.straightLine.style="",o.eraser.style.border="3px solid red",o.state.currentTool="eraser",b.canvas.style.cursor="url('src/screens/canvas/images/eraser.cur'),auto";break;case o.paintBacket:b.auxiliaryCanvas.style.visibility="hidden",o.pen.style.border="",o.allPixelsColor.style.border="",o.eraser.style.border="",o.straightLine.style="",o.paintBacket.style.border="3px solid red",o.state.currentTool="paintBucket",b.canvas.style.cursor="url('src/screens/canvas/images/paintBucket.cur'),auto";break;case o.allPixelsColor:b.auxiliaryCanvas.style.visibility="hidden",o.pen.style.border="",o.eraser.style.border="",o.paintBacket.style.border="",o.straightLine.style="",o.allPixelsColor.style.border="3px solid red",o.state.currentTool="allPixelsColor",b.canvas.style.cursor="url('src/screens/canvas/images/drop.cur'),auto";break;case o.straightLine:o.pen.style.border="",o.eraser.style.border="",o.paintBacket.style.border="",o.allPixelsColor.style.border="",o.straightLine.style.border="3px solid red",o.state.currentTool="straightLine",b.auxiliaryCanvas.style.cursor="url('src/screens/canvas/images/pen.cur'),auto",b.auxiliaryCanvas.style.visibility="visible",b.auxiliaryContext.clearRect(0,0,o.newCanvas.width,o.newCanvas.height),b.auxiliaryContext.drawImage(b.canvas,0,0),l=new s(b),b.auxiliaryCanvas.addEventListener("mousedown",n=>{v=I(o.primaryColor.value),h=I(o.secondaryColor.value),b.color=v,3===n.which&&(b.color=h),l.mousedown(n)}),b.auxiliaryCanvas.addEventListener("mousemove",n=>{l.mousemove(n)}),b.auxiliaryCanvas.addEventListener("mouseup",()=>{l.mouseup(),p=b.canvas.toDataURL(),f=document.getElementsByClassName("active")[0],(m=f.getElementsByTagName("img")[0]).src=p})}}),o.addFrame.addEventListener("click",()=>{x.addAndDelete(b.frames),o.context.clearRect(0,0,b.canvas.width,b.canvas.height),o.auxiliaryContext.clearRect(0,0,b.canvas.width,b.canvas.height);setInterval(()=>{g>b.images.length-1&&(g=0),o.preview.src=b.images[g].src,g++},1e3)})}]);
//# sourceMappingURL=app.bundle.js.map